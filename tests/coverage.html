
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>parsex: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bbfh-dev/parsex/parsex/cli.go (87.3%)</option>
				
				<option value="file1">github.com/bbfh-dev/parsex/parsex/cli_args.go (96.0%)</option>
				
				<option value="file2">github.com/bbfh-dev/parsex/parsex/cli_help.go (100.0%)</option>
				
				<option value="file3">github.com/bbfh-dev/parsex/parsex/cli_valid.go (85.7%)</option>
				
				<option value="file4">github.com/bbfh-dev/parsex/parsex/input.go (100.0%)</option>
				
				<option value="file5">github.com/bbfh-dev/parsex/parsex/internal/errors.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package parsex

import (
        "fmt"
        "os"
        "strings"

        "github.com/bbfh-dev/parsex/parsex/internal"
)

// Function to be run with the provided arguments and flags
type Program func(in Input, args ...string) error

// The primary handler for a single sub-command
type CLI struct {
        Name       string
        cliProgram Program
        cliArgs    []Arg
        argToIndex map[string]int
        arguments  []string
        input      Input
        inArgs     []string
}

// Create a new program. Use for both main entry and branches (sub-commands)
func New(name string, program Program, args []Arg) *CLI <span class="cov8" title="1">{
        prepend := []Arg{{Name: "help", Match: "--AUTO", Desc: "print help message and exit"}}
        args = applyAutoFlags(append(prepend, args...))
        return &amp;CLI{
                Name:       name,
                cliProgram: program,
                cliArgs:    args,
                argToIndex: argToIndexMap(args),
                arguments:  []string{},
                input:      Input{},
                inArgs:     []string{},
        }
}</span>

func (cli *CLI) reset() *CLI <span class="cov8" title="1">{
        cli.input = Input{}
        cli.inArgs = []string{}

        return cli
}</span>

// Set input arguments from a string
//
// Example: `-o /tmp/ --verbose`
func (cli *CLI) FromString(str string) *CLI <span class="cov8" title="1">{
        cli.arguments = simplifyArgs(strings.Split(str, " "))
        return cli.reset()
}</span>

// Set input arguments from os.Args (provided from calling the binary)
func (cli *CLI) FromArgs() *CLI <span class="cov0" title="0">{
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                cli.arguments = simplifyArgs(os.Args[1:])
        }</span>
        <span class="cov0" title="0">return cli.reset()</span>
}

// Set input arguments directly
func (cli *CLI) FromSlice(args []string) *CLI <span class="cov8" title="1">{
        cli.arguments = simplifyArgs(args)
        return cli.reset()
}</span>

// Parse input arguments and execute the correct program
func (cli *CLI) Run() error <span class="cov8" title="1">{
        var expectsArgumentsOnly bool
        var i int
        for i &lt; len(cli.arguments) </span><span class="cov8" title="1">{
                if expectsArgumentsOnly &amp;&amp; strings.HasPrefix(cli.arguments[i], "-") </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "Unexpected option %q after arguments. Make sure all arguments are provided in the end or after --",
                                cli.arguments[i],
                        )
                }</span>

                <span class="cov8" title="1">if cli.arguments[i] == "--" </span><span class="cov8" title="1">{
                        if len(cli.arguments) &gt; i+1 </span><span class="cov8" title="1">{
                                cli.inArgs = append(cli.inArgs, cli.arguments[i+1:]...)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">arg, err := cli.findArg(cli.arguments[i], i)
                if err != nil </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(cli.arguments[i], "-") </span><span class="cov8" title="1">{
                                cli.inArgs = append(cli.inArgs, cli.arguments[i])
                                expectsArgumentsOnly = true
                                i += 1
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">if arg.Branch != nil </span><span class="cov8" title="1">{
                        arg.Branch.input = cli.input
                        arg.Branch.inArgs = cli.inArgs
                        if len(cli.arguments) &gt; i+1 </span><span class="cov8" title="1">{
                                arg.Branch.arguments = cli.arguments[i+1:]
                        }</span>
                        <span class="cov8" title="1">return internal.PrefixErr(arg.Name, arg.Branch.Run())</span>
                }

                <span class="cov8" title="1">diff, err := cli.processArg(arg, cli.arguments[i:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">i += diff</span>
        }

        <span class="cov8" title="1">if cli.input.Has("help") </span><span class="cov8" title="1">{
                fmt.Println(cli.Help(cli.Name))
                return nil
        }</span>

        <span class="cov8" title="1">return cli.cliProgram(cli.input, cli.inArgs...)</span>
}

func (cli *CLI) findArg(current string, i int) (Arg, error) <span class="cov8" title="1">{
        for keyFrom := range cli.argToIndex </span><span class="cov8" title="1">{
                if keyFrom == current </span><span class="cov8" title="1">{
                        return cli.cliArgs[cli.argToIndex[current]], nil
                }</span>
        }

        <span class="cov8" title="1">return Arg{}, fmt.Errorf("Unknown argument (#%d): %s", i+1, current)</span>
}

func (cli *CLI) processArg(arg Arg, source []string) (int, error) <span class="cov8" title="1">{
        if arg.Check == nil </span><span class="cov8" title="1">{
                cli.input[arg.Name] = ""
                return 1, nil
        }</span>

        <span class="cov8" title="1">if len(source) &lt; 2 </span><span class="cov0" title="0">{
                return 1, fmt.Errorf("Argument %q requires a value!", arg.Name)
        }</span>

        <span class="cov8" title="1">cli.input[arg.Name] = source[1]

        return 2, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package parsex

import (
        "fmt"
        "strings"
        "unicode"
)

type Arg struct {
        // Name is used for you to identify this argument later inside of parsex.Input
        Name string

        // Comma separated strings to match inside of input arguments.
        //
        // Example: "--output,-o" or "--AUTO,-o" where Arg.Name = "output".
        //
        // any occurance of `--AUTO` will be replaced with the lowecase Arg.Name
        Match string

        // Description of the argument to be printed in the help documentation
        Desc string

        // (Optional) Require an argument after the option of a specific valid value
        Check Validator

        // (Optional) Make this argument a subcommand, all arguments aftwards will be handled by this Arg.Branch
        Branch *CLI
}

func applyAutoFlags(args []Arg) []Arg <span class="cov8" title="1">{
        for i := range args </span><span class="cov8" title="1">{
                args[i].Match = strings.ReplaceAll(args[i].Match, "AUTO", strings.ToLower(args[i].Name))
        }</span>
        <span class="cov8" title="1">return args</span>
}

// Creates a map of singular options to their coresponding arg.Match
func argToIndexMap(args []Arg) map[string]int <span class="cov8" title="1">{
        out := map[string]int{}

        for i, arg := range args </span><span class="cov8" title="1">{
                for _, key := range strings.Split(arg.Match, ",") </span><span class="cov8" title="1">{
                        out[key] = i
                }</span>
        }

        <span class="cov8" title="1">return out</span>
}

func isCombinedArg(arg string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(arg, "-") &amp;&amp; !strings.HasPrefix(arg, "--") &amp;&amp;
                !unicode.IsUpper(rune(arg[1]))
}</span>

func simplifyArgs(args []string) []string <span class="cov8" title="1">{
        var out []string

        for _, arg := range args </span><span class="cov8" title="1">{
                if len(arg) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(arg, "--") &amp;&amp; strings.Contains(arg, "=") </span><span class="cov8" title="1">{
                        out = append(out, strings.Split(arg, "=")...)
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(arg, "-") &amp;&amp; unicode.IsUpper(rune(arg[1])) &amp;&amp; len(arg) &gt; 2 </span><span class="cov8" title="1">{
                        out = append(out, arg[:2], arg[3:])
                        continue</span>
                }

                <span class="cov8" title="1">if isCombinedArg(arg) </span><span class="cov8" title="1">{
                        for _, char := range arg[1:] </span><span class="cov8" title="1">{
                                out = append(out, fmt.Sprintf("-%s", string(char)))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">out = append(out, arg)</span>
        }

        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package parsex

import "strings"

const HELP_ARG_WIDTH = 16

func (cli *CLI) Help(cmd string) string <span class="cov8" title="1">{
        var builder strings.Builder

        builder.WriteString("Usage: " + cmd + " [OPTIONS] &lt;ARGUMENTS...&gt;\n")

        var commandsBuilder strings.Builder
        var optionsBuilder strings.Builder

        for _, arg := range cli.cliArgs </span><span class="cov8" title="1">{
                if arg.Branch == nil </span><span class="cov8" title="1">{
                        optionsBuilder.WriteString("    " + arg.Match)
                        optionsBuilder.WriteString(strings.Repeat(" ", HELP_ARG_WIDTH-len(arg.Match)))
                        optionsBuilder.WriteString(arg.Desc + "\n")
                }</span> else<span class="cov8" title="1"> {
                        commandsBuilder.WriteString("    " + arg.Match)
                        commandsBuilder.WriteString(strings.Repeat(" ", HELP_ARG_WIDTH-len(arg.Match)))
                        commandsBuilder.WriteString(arg.Desc + "\n")
                }</span>
        }

        <span class="cov8" title="1">if len(commandsBuilder.String()) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString("\nCommands:\n")
                builder.WriteString(commandsBuilder.String())
        }</span>

        <span class="cov8" title="1">if len(optionsBuilder.String()) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString("\nOptions:\n")
                builder.WriteString(optionsBuilder.String())
        }</span>

        <span class="cov8" title="1">return builder.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package parsex

import (
        "path/filepath"
        "strconv"
)

// Ensures that the argument is valid.
// The returning string is an optionally transformed input string
type Validator func(string) (string, bool)

// Require a string argument. No modifications
func ValidString(in string) (string, bool) <span class="cov8" title="1">{
        return in, true
}</span>

// Require a valid path. Transforms into an absolute path
func ValidPath(in string) (string, bool) <span class="cov8" title="1">{
        path, err := filepath.Abs(in)
        if err != nil </span><span class="cov0" title="0">{
                return in, false
        }</span>

        <span class="cov8" title="1">return path, true</span>
}

// Require an integer argument. No modifications
func ValidInt(in string) (string, bool) <span class="cov8" title="1">{
        _, err := strconv.Atoi(in)
        return in, err == nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package parsex

// Input is a map of flags/options that were provided to the program.
//
// All keys are equalent to Arg.Name, flags have an empty value.
//
// Use Input.Has("&lt;key&gt;") to check if a flag is passed.
//
// Access it the same way as a map, e.g. Input["&lt;key&gt;"]
type Input map[string]string

// Check that a flag was passed
func (input Input) Has(key string) bool <span class="cov8" title="1">{
        _, ok := input[key]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package internal

import "fmt"

// Add prefix to an error if err != nil
func PrefixErr(prefix string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("%s: %w", prefix, err)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
